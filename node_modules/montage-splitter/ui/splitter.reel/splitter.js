/**
 * @module montage-splitter/ui/splitter.reel
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component;
var AbstractControl = require("montage/ui/base/abstract-control").AbstractControl,
    TranslateComposer = require("montage/composer/translate-composer").TranslateComposer,
    KeyComposer = require("montage/composer/key-composer").KeyComposer,
    Dict = require("montage/collections/dict");

/**
 * @class Splitter
 * @extends Component
 */
exports.Splitter = AbstractControl.specialize(/** @lends Splitter# */ {

    // Lifecycle
    constructor: {
        value: function Splitter() {
            this.super();
            AbstractControl.constructor.call(this); // super
            //this is so that when we read properties from the dom they are not overwritten

            this.defineBinding( "classList.has('is-disabled')", { "<-": "!enabled" });
            this.defineBinding( "classList.has('is-active')", { "<-": "active" });
            this.defineBinding( "classList.has('is-collapsed')", { "<-": "collapsed" });
            this.addOwnPropertyChangeListener("splitAxis", this);
            this.addOwnPropertyChangeListener("fixedPane", this);
            window.addEventListener("resize", this, false);
            this.splitAxis = "vertical";
        }
    },

    enterDocument: {
        value: function (firstTime) {
            if (firstTime) {
                this._translateComposer = new TranslateComposer();
                this._translateComposer.identifier = "resizer";
                this._translateComposer.axis = !this.splitAxis;
                this._translateComposer.hasMomentum = false;
                this.addComposerForElement(this._translateComposer, this._resizerElement);

                // check for transform support
                if("webkitTransform" in this.element.style) {
                    this._transform = "webkitTransform";
                } else if("MozTransform" in this.element.style) {
                    this._transform = "MozTransform";
                } else if("oTransform" in this.element.style) {
                    this._transform = "oTransform";
                } else {
                    this._transform = "transform";
                }
                if (this.fixedPane === null) {
                    //use defaults
                    if(this.splitAxis === "vertical") {
                        this.handleFixedPaneChange("first");
                    } else {
                        this.handleFixedPaneChange("second");
                    }
                } else {
                    this.handleFixedPaneChange(this.fixedPane);
                }
                // set flag so that we can setup the split in a reasonable position.
                this._firstTime = true;
            }
        }
    },

    // AbstractSlider overides

    _calculateSplitterSize: {
        value: function() {
            if(this.splitAxis === "vertical") {
                return this.element.offsetWidth;
            } else {
                return this.element.offsetHeight;
            }

        }
    },

    willDraw: {
        value: function () {
            //size is updated at every draw
            this._size = this._calculateSplitterSize();

            if(this._firstTime) {
                this._baseFlexBasis = this.initialFixedSize;
                this._firstTime = false;
            }

            //in case the splitter was resized in the mean time.
            if (this.active && this._baseFlexBasis > this._size) {
                this._baseFlexBasis = this._size;
            }
        }
    },

    draw: {
        value: function () {
            if(this.fixedPane === "first" || this.fixedPane === null && this.splitAxis === "vertical") {
                this._firstPane.classList.add("is-fixed");
                this._firstPane.classList.remove("is-fill");
                this._secondPane.classList.add("is-fill");
                this._secondPane.classList.remove("is-fixed");
            } else {
                this._firstPane.classList.remove("is-fixed");
                this._firstPane.classList.add("is-fill");
                this._secondPane.classList.remove("is-fill");
                this._secondPane.classList.add("is-fixed");
            }
            if(!this.collapsed) {
                this._currentFlexBasis = this._baseFlexBasis + this._translate;
                this._controlledElement.style.webkitFlexBasis = this._currentFlexBasis + "px";
            } else {
                this._controlledElement.style.webkitFlexBasis = "0px";
            }
        }
    },

    handleResizerTranslateStart: {
        value: function (e) {
            this.active = true;
            //to avoid text selection
            document.body.style.pointerEvents = "none";
            if(this.splitAxis === "horizontal") {
                this._startTranslate = e.translateY;
            } else {
                this._startTranslate = e.translateX;
            }
            this._startValue = this.value;
        }
    },

    handleResizerTranslate: {
        value: function (event) {
            if(this.splitAxis === "horizontal") {
                this._translate = this._startTranslate - event.translateY;
            } else {
                this._translate = event.translateX - this._startTranslate;
            }
        }
    },

    handleResizerTranslateEnd: {
        value: function (e) {
            //to restore text selection
            document.body.style.pointerEvents = "auto";
            this.active = false;
            //store so that we start from there next time.
            this._baseFlexBasis = this._currentFlexBasis;
            this.__translate = 0;
        }
    },

    // Event Handlers

    handleResize: {
        value: function(event) {
            this._updateValueFromDom();
        }
    },


    handleDblclick: {
        value: function (event) {
            this.collapsed = !this.collapsed;
            event.stopPropagation();
        }
    },

    // Properties

    /**
     * This property is true when the slider is being interacted with, either through mouse click or touch event, otherwise false.
     * @type {boolean}
     * @default false
     */
    active: {
        value: false
    },

    collapsed: {
        value: false
    },

    splitAxis: {
        value: null
    },

    fixedPane: {
        value: null
    },

    _controlledElement: {
        value: null
    },

    // Stuff

    handleSplitAxisChange: {
        value: function() {
            if(this.splitAxis === "vertical") {
                this.classList.add("is-verticalSplit");
                this.classList.remove("is-horizontalSplit");
            } else {
                this.classList.remove("is-verticalSplit");
                this.classList.add("is-horizontalSplit");
            }
        }
    },

    handleFixedPaneChange: {
        value: function(newValue) {
            if (newValue === "first") {
                this._controlledElement = this._firstPane;
            } else {
                this._controlledElement = this._secondPane;
            }
        }
    },

    __translate: {
         value: 0
     },

     _translate: {
         get: function () {
             return this.__translate;
         },
         set: function (value) {
             this.__translate = value;
             this.needsDraw = true
         }
     },

    // Lifecycle

    surrenderPointer: {
        value: function (pointer, composer) {
            // If the user is sliding us then we do not want anyone using
            // the pointer
            return false;
        }
    },

    // Properties

    /**
     * Enables or disables the Button from user input. When this property is
     * set to `false`, the "disabled" CSS style is applied to the button's DOM
     * element during the next draw cycle. When set to `true` the "disabled"
     * CSS class is removed from the element's class list.
     * @type {boolean}
     */
    enabled: {
        value: true
    },

    splitAxis: {
        value: null
    },

    initialFixedSize: {
        value: 250
    },

    // Machinery
    _firstTime: {
        value: null
    },

    _size: {
        value: 0
    },

    _baseFlexBasis: {
        value: 0
    },

    _currentFlexBasis: {
        value: 0
    },

    _resizerElement: {
        value: null
    },

    _translateComposer: {
        value: null
    },

    _transform: {
        value: null
    },

    _transition: {
        value: null
    },

    _startTranslate: {
        value: null
    },

    // Override abstract-slider.js
    // because this slider does not use any thumb, the abstract-slider is missing a component.
    prepareForActivationEvents: {
        value: function () {
            this._translateComposer.addEventListener('translateStart', this, false);
            this._translateComposer.addEventListener('translate', this, false);
            this._translateComposer.addEventListener('translateEnd', this, false);
            this._resizerElement.addEventListener("dblclick", this, false);
        }
    },

    acceptsActiveTarget: {
        value: false
    }
});
